#!/usr/bin/env ruby

#
# CBRAIN Project
#
# Original author: Pierre Rioux
#
# $Id$
#

# This script is a wrapper that launches the normal Rails script/server,
# but with the added ability of receiving the content if the database.yml
# file in standard output before it does so. Also, once the server is
# started, the database.yml is deleted outright, closing a security hole.

# The command-line args are to be provided strictly in the order shown
# below, and all of them should be present (this is done simply so that
# this bash script is kept simple, as anyway this script is not meant
# to be started manually by users).


# To start the Rails app:
#
#   $0 start -e <environment> -p <port>
#
# which will result in reading the database.yml from stdin, installing
# it, executing this command
#
#   script/server -e <environment> -p <port> -b 127.0.0.1 -d
#
# and finally removing the database.yml file. Any database.yml file
# already present before doing all this will be backed up in
#
#     database.yml.cbrain_remote_bak.
#
# Note that if stdin contains nothing (zero bytes) the current
# database.yml file will be used, or the script will restore and use
# the backup file 'database.yml.cbrain_remote_bak'.


# To stop the Rails app:
#
#   $0 stop
#
# which will result in killing the rails app.


# This script is written in a way that depends
# on as few ruby libraries as possible.


#########################
# S U B R O U T I N E S #
#########################

# Usage
def usage(basename)
    puts "Usage: #{basename} start -e <environment> -p <port>\n" +
         "       #{basename} stop"
    Kernel.exit(10)
end

# Fatal error message
def fatal(message)
    puts message
    Kernel.exit(20)
end

# Run-time paths
cwd      = Dir.getwd
basename = $PROGRAM_NAME
fullprog = basename =~ /^\// ? basename : cwd + "/" + basename

# Rails-specific paths
rails_home = fullprog.sub(/\/script\/.+$/,"")
pidfile    = "#{rails_home}/tmp/pids/mongrel.pid"

# Check usage
usage(basename) if ARGV.size !=1 && ARGV.size != 5    # 1 or 5 args!

# To help diagnose problems, print Ruby's version.
puts "You are using Ruby #{VERSION}"

#############################################################
# Stop
#############################################################

if ARGV.size == 1
    usage(basename) if ARGV[0] != "stop"
    fp = File.open(pidfile,"r") rescue nil
    if fp
        pid = fp.read.to_i
        fp.close
        Process.kill("TERM", pid)
        puts "Bourreau Stopped"
        Kernel.exit(0)
    end
    fatal "Could not find/open PID file '#{pidfile}'."
end

#############################################################
# Start
#############################################################

usage(basename) if ARGV[0] != "start" || ARGV[1] != "-e" || ARGV[3] != "-p"
if File.exist?(pidfile)
  pid = File.read(pidfile).to_i
  # TODO make check for running process platform-independent
  fatal("The Rails app seems to be already running. Kill it first.") if File.exist?("/proc/#{pid}")
  File.unlink(pidfile) rescue true
end

# Check arguments
environment = ARGV[2]
port        = ARGV[4].to_i
fatal("Environment argument must be 'production', 'development' or 'test'") unless
   environment =~ /^(production|development|test)$/
fatal("Port argument must be a number greater than 1024 and less than 65530") unless
   port > 1024 && port < 65535

db_yml_text = STDIN.read || ""
db_file     = rails_home + "/config/database.yml"
db_file_bak = rails_home + "/config/database.yml.cbrain_remote_bak"

# Install or restore database.yml if necessary
db_exists  = File.exist?(db_file)
bak_exists = File.exist?(db_file_bak)
blank_yml  = db_yml_text !~ /\S/

if blank_yml #  blank? use what db.yml is already here
  if db_exists
    # nothing to do
  elsif bak_exists
    File.rename(db_file_bak,db_file)
  else
    fatal("Could not find a database.yml file for the Rails application!")
  end
else # db text is provided to us
  if db_exists
    File.rename(db_file,db_file_bak) # will crush existing bak file
  end
  File.open(db_file,"w") { |fh| fh.write(db_yml_text) }
end

# This environment variable holds the path to a status
# file created by the server 'cbrain_mongrel_rails' at startup;
# it will contain the word 'STARTED' or 'STOPPED'. This will happen
# even if the server crashes early on.
status_file = rails_home + "/tmp/pids/mongrel.status"
ENV["CBRAIN_SERVER_STATUS_FILE"] = status_file
File.unlink(status_file) rescue true # Make sure it's not there at all

# Start the server
Dir.chdir(rails_home) do
  # Note that the options for 'cbrain_mongrel_rails' are the same as
  # for 'mongrel_rails', but they are different from 'script/server'
  # (in particular, -b becomes -a).
  cmd = "script/cbrain_mongrel_rails start -d -p #{port} -e #{environment} -a 127.0.0.1 -P #{pidfile}"
  system(cmd) # the -d will start it in background
end

# Wait for the status file to appear; it will appear whether or not the
# server was able to properly start.
start_check = Time.now
while start_check > (Time.now - 120)  # check for two minutes, at most
  sleep 1
  break if File.exists?(status_file)
end

# If we were provided with a database.yml, we need
# to wait a bit and delete it once the server has read
# it.
if ! blank_yml
  File.unlink(db_file)
end

# Return a message to indicate to our calling context
# whether or not the server started.
status_message = File.read(status_file) rescue "FAILED\n";
if status_message =~ /STARTED/i # see Bourreau's validation.rb
  puts "Bourreau Started"
else
  puts "Bourreau Failed"
end
Kernel.exit(0)

