#!/usr/bin/env ruby

# This rspec file tests the Boutiques framework on the Portal side.
# It uses a test (mock) application to do so.
# This set of tests does the following:
#   (1) Validates the JSON descriptor
#   (2) Tests that the local script behaviour is as expected
#   (3) Tests the generated portal task class (including the after_form method)

# Helper testing methods
require_relative 'test_helpers'

# Gain access to the rails environment
require 'rails_helper'
require 'spec_helper'

# Add helper methods for performing tests
include TestHelpers

# Run the Boutiques test on the BrainPortal side
describe "BrainPortal Boutiques Tests" do

  # Run before block to create required input files
  before(:all) do
    createInputFiles
  end

  # Post-test cleanup via after block
  after(:all) do
    destroyInputFiles
    destroyOutputFiles
  end

  # Validate correctness of JSON descriptor
  describe "JSON descriptor" do
    it "validates" do
      schemaLoc = File.join(SchemaTaskGenerator::SCHEMA_DIR, SchemaTaskGenerator::DEFAULT_SCHEMA_FILE)
      expect( runAndCheckJsonValidator(schemaLoc) ).to eql(true)
    end
  end

  # Run tests locally on script
  describe "Local script test" do

    # After each local test, destroy the output files
    after(:each) do
      destroyOutputFiles
    end

    # Perform the local tests to make sure the program behaves as expected
    # (especially as it is changed to add new Boutiques features)
    BasicTests.each do |test|
      it "#{test[0]}" do
        expect( runTestScript( test[1], test[3] || [] ) ).to eq( test[2] )
      end
    end

  end

  # Run tests on generated portal tasks
  describe 'local boutiques task' do

    # Run before block to create required task and task class
    before(:each) do
      execer         = create(:bourreau)
      schema         = SchemaTaskGenerator.default_schema
      descriptor     = File.join(__dir__, TestScriptDescriptor)
      @boutiquesTask = SchemaTaskGenerator.generate(schema, descriptor)
      @boutiquesTask.integrate if File.exists?(descriptor)
      @task          = CbrainTask::BoutiquesTest.new
      @task.bourreau = execer
      @task_const    = "CbrainTask::#{SchemaTaskGenerator.classify(@task.name)}".constantize
    end

    # Test the object generated by the Boutiques generator
    context "Boutiques GeneratedTask Object" do
      it "should have the right name" do
        expect( @boutiquesTask.name ).to eq( "BoutiquesTest" )
      end
      it "should have no validation errors" do
        expect( @boutiquesTask.validation_errors ).to be true
      end
    end

    # Test the portal class automatically generated and registered in cbrain via the GeneratedTask Object
    context "Boutiques Generated Class Properties" do
      it "should have the right task class name" do
        expect( @task_const.to_s ).to eq( "CbrainTask::BoutiquesTest" )
      end
      it "should have a tool" do
        expect( Tool.exists?(:cbrain_task_class => @task_const) ).to be true
      end
      it "should have no public path" do # Just test the help file
        expect( @task_const.public_path("edit_params_help.html") ).to eq( nil )
      end
      it "should have access to its generated source object" do
        expect( @task_const.generated_from ).to eq( @boutiquesTask  )
      end
      it "has all raw partials" do
        expect( @task_const.raw_partial(:task_params) ).not_to eq( nil )
        expect( @task_const.raw_partial(:show_params) ).not_to eq( nil )
        expect( @task_const.raw_partial(:edit_help)   ).not_to eq( nil )
      end
      it "has pretty param names" do
        allThere = TestArgs.all? { |s| @task_const.pretty_params_names[s] == s.to_s }
        expect( allThere ).to be true
      end
      it "has expected default values" do # Only -r has a default value
        expect( @task_const.default_launch_args[:'r'] ).to eq( 'r' )
      end
    end

    # Test an object instantiated from the portal class generated by the Boutiques framework
    context "Generated Portal Task" do
      # General properties of the Portal task class/object
      it "should have the right name" do
        expect( @task.name ).to eq( "BoutiquesTest" )
      end
      it "should have a bourreau" do
        expect( @task.bourreau ).not_to eq( nil )
      end
      it "should have a tool id" do
        expect( @task.tool.id  ).not_to eq( nil )
      end

      # The before_form method should fail if no UserFiles are given, but work otherwise
      # Here, UserFile existence is merely simulated, and before_form is tested in isolation
      describe "Generated before_form Method" do
        before(:each) do
          @task.params = {}
        end
        it "should fail when no input files are given" do
          expect { @task.before_form }.to raise_error(CbrainError, "Error: this task requires at least one input file")
        end
      end

      # Test the after_form method of the object
      # We run essentially the same test inputs as those sent to the local script, except
      # that we skip tests that check aspects that the isolated after_form cannot handle
      describe "Generated after_form Method" do
        # after_form cannot check userfiles or flag existence (i.e. against the application) in this isolated test
        ignoredMsgs = ["invalid or missing userfile"]
        BasicTests.all? do |t|
          # Ignore tests requiring file existence checks (10 is an exit code for file existence check failure)
          # or tests that would need to check against the actual application (e.g. recognize argument existence).
          # The latter problem is excluded at a different level than after_form (since no input form will be created for it).
          next true if !t[3].nil? || t[2]==10 || t[0].include?("unrecognized")
          # Perform after_form test
          it "after_form #{t[0]}" do
            @task.params_errors.clear # Reset to having no errors
            @task.params = ArgumentDictionary.( t[1].dup )
            @task.params[:f] ||= [] # after_form expects [], not nil, for empty file lists
            @task.after_form # Run the method
            errMsgs = @task.params_errors.full_messages
            # Cannot check userfile existence and so on in this isolated test, so ignore those errors
            errMsgs.delete_if { |m| ignoredMsgs.any? { |e| m.include?(e) } }
            # When there is an error, the exit code should be non-zero; no errors should be present otherwise
            expect(
              (errMsgs.length == 0 && t[2] == 0) || (errMsgs.length > 0 && t[2] != 0)
            ).to be true
            @task.params = {} # Clean up; @task is shared between tests
          end
        end
      end

    end


  end


end

