
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# NOTE: This is a working template generated from a descriptor:
# [Schema]         <%= schema['id'] %>
# [Schema version] <%= descriptor['schema-version'] %>
# [Tool]           <%= descriptor['name'] %>
# [Version]        <%= descriptor['tool-version'] || '?' %>
# See the CbrainTask Programmer Guide (CBRAIN Wiki) for a more complete picture
# of how CbrainTasks are constructed.
% # NOTE: This template's weird indentation is there to try and make the
% # generated code as legible as possible.

# Portal-side CbrainTask subclass to launch <%= name %>
class CbrainTask::<%= name %> < <%= descriptor['cbrain:inherits-from-class'] || 'PortalTask' %>

  Revision_info=CbrainFileRevision[__FILE__] #:nodoc:

% # Maximum width of a given +key+'s value in a +list+ of hashes
% max_width = lambda do |list, key|
%   list.map { |i| i[key].to_s.length rescue 0 }.max
% end
%
% # Parameter types
% params       = descriptor['inputs'].dup
% outputs      = descriptor['output-files'].dup
% required     = params.select { |i| ! i['optional']     }
% optional     = params.select { |i| i['optional']       }
% defaults     = params.select { |i| i['default-value']  }
% files        = params.select { |i| i['type'] == 'File' }
% file_lists   = files.select  { |i| i['list']           }
%
% # Parameter groups
% groups    = descriptor['groups'].dup rescue []
% noGroups  = (groups.length == 0)
% gIdToMbrs = groups.inject({}){ |m,v| m.merge( v["id"] => v["members"] ) }
% gIdToPrms = gIdToMbrs.map { |k,v| [k, params.select{ |p| v.include? p["id"] }] }.to_h
%
% # Parameter Maps: ids => [ target_ids ] for disables/requires
% disables_map = params.inject({}){ |hmap,i| (res=i["disables-inputs"]) ? hmap.merge(i["id"]=>res) : hmap }
% requires_map = params.inject({}){ |hmap,i| (res=i["requires-inputs"]) ? hmap.merge(i["id"]=>res) : hmap }

% # Special case; we only have one file input parameter and it only
% # allows single files.
% single_file = files.first if files.count == 1 && file_lists.empty?
% if single_file
%   # The parameter's validation is made in final_task_list and is no longer
%   # optional if it was.
%   params.delete(single_file)
%   required.delete(single_file)
%   optional.delete(single_file)
% end
%
  # Task properties are special boolean properties of your task, returned as a
  # hash table. Used internally by CBRAIN to enable/disable special task
  # handling. All properties are unset (false) by default.
  #
  # Both generated task classes (ClusterTask for the Bourreau, PortalTask for
  # the Portal) have different properties as they have different use cases.
  # The properties below are for the Portal-side class (PortalTask).
  def self.properties #:nodoc:
    super.merge({
      # The task's parameter view doesn't have a submit button, and one should
      # be added automatically. Note that the views automatically generated
      # along with this template *do* have a submit button.
      :no_submit_button => false,

      # Disable the use of presets (saved parameters). If enabled, the preset
      # panel is shown above the task's parameter view and allows users to
      # save a task's parameters and re-use them later to launch another similar
      # task.
      :no_presets => false,

      # Allow CBRAIN to parallelize multiple instances of this task/job on a
      # single cluster node; each job's generated shell script will be run
      # as a background job on the node at the same time and CBRAIN will wait
      # for all tasks to be done before moving to the data processing stage.
      :use_parallelizer => false,

      # Indicate that this task may alter its input files, and thus the task's
      # owner must have write access to the input files to be allowed to launch
      # the task. Most tasks do not alter their input files, but this is a safe
      # default.
      :readonly_input_files => <%=
        if descriptor.has_key?('cbrain:readonly-input-files')
          !!descriptor['cbrain:readonly-input-files']
        elsif descriptor.has_key?('cbrain:alters-input-files')
          !descriptor['cbrain:alters-input-files']
        else
          false
        end
      %>,
    })
  end

% unless defaults.empty?
  # Default values for some (all?) of <%= name %>'s parameters. Those values
  # reflect the defaults taken by the tool's developer; feel free to change
  # them to match your platform's requirements.
  def self.default_launch_args #:nodoc:
    {
%   id_width = max_width.(defaults, 'id') + "'".length
%   defaults.each do |default|
      <%=
        ":'%-#{id_width}s => %s," % [
          default['id'] + "'",
          default['default-value'].inspect
        ]
      %>
%   end
    }
  end

% end
  # Callback called just before the task's form is rendered. At this point,
  # the task's params hash contains at least the default list of input
  # userfiles under the key :interface_userfile_ids.
  def before_form #:nodoc:
% file_types = descriptor['inputs']
%   .select { |i| ! i['optional'] && i['type'] == 'File' }
%   .map    { |i| i['cbrain-file-type'] }
%   .uniq
% unless file_types.empty?
    # Resolve interface_userfile_ids to actual userfile objects
    files = Userfile.find_all_by_id(self.params[:interface_userfile_ids])

%   if file_types.length == 1 && !file_types.first
    # At least one file is required.
    cb_error "Error: this task requires at least one input file" if files.empty?
%   else
    # Some input files are not optional and specific file types are
    # required. Make sure the given input files are adequate.

    # Ensure that +files+ contains at least one file of type +type+
    ensure_one = lambda do |files, type|
      type = type.constantize unless type.is_a?(Class)
      cb_error "Error: this task requires at least one file of type '#{type.name}'" unless
        files.any? { |f| f.is_a?(type) }
    end

%     file_types.compact.each do |type|
    ensure_one.(files, '<%= type %>')
%     end
%   end

% end
    ""
  end

  # Callback called just after the task's form has been submitted by the user.
  # At this point, all the task's params will be filled. This is where most
  # validations happen.
  def after_form #:nodoc:
% unless params.empty?
    params = self.params

%   unless file_lists.empty?
    # Assign the default input file list from interface_userfile_ids to unset
    # file list parameters (unless they are optional).
    [
%     file_lists.select{ |f| ! f['optional'] }.each do |param|
      :'<%= param['id'] %>',
%     end
    ].each do |list|
      params[list] = params[:interface_userfile_ids].dup unless
        params[list].is_a?(Enumerable) # Allows explicitly empty lists
    end

%   end
    # Sanitize every input parameter according to their expected type

%   sanitize_param = format_call('sanitize_param', params) { |param| [
%     ":'#{param['id']}'",
%     ":#{param['type'].downcase}",
%     (param['cbrain-file-type'] ? ":file_type => '#{param['cbrain-file-type']}'" : nil)
%   ] }
%
%   unless required.empty?
    # Required parameters
%     required.each do |param|
    <%= sanitize_param.(param) %>
%     end

%   end
%   unless optional.empty?
    # Optional parameters
%     calls      = optional.map { |param| [ sanitize_param.(param), param ] }
%     call_width = calls.map { |c, p| c.length }.max
%     calls.each do |call, param|
    <%= "%-#{call_width}s unless params[:'%s'].nil?" % [ call, param['id'] ] %>
%     end

%   end
%#
%####
%# Constraint and type checks
%#
    # Helpers
% idsym    = lambda { |param| ":'#{param['id']}'" }
% nilcheck = lambda { |param| "params[#{idsym.(param)}].nil?" }
    list = lambda { |sym| (s = params[sym]).is_a?(Enumerable) ? s : [s] }

    # Helper function for detecting inactive parameters (or false for flag-type parameters)
    # Note that empty strings are allowed and no parameter types except flags pass booleans
    isInactive = lambda { |x| params[x].nil? || (params[x]==false) }

%#
%# Enum Check
% hasEnumVars = params.any?{ |p| p['type'].downcase == 'enum' }
% if hasEnumVars
    # Check that any enum parameters have been given allowable values
    errmsg = "was not given an acceptable value!"
%  for param in params
%   next unless param['type'].downcase == 'enum'
%   check = '[' + param['enum-value-choices'].map{ |s| "'#{s}'" }.join(',') + "].include?(params[#{idsym.(param)}])"
    params_errors.add(<%=idsym.(param)%>, errmsg) unless <%= nilcheck.(param) %> || <%= check %>
%  end

% end # hasEnumVars check
%#
%# Min/max/int Number check
% if params.any? { |p| p['minimum'] || p['maximum'] || p['integer'] }
    # Check that number parameters with contraints have been given permissable values
% nerrmsg = lambda { |prm,str| "\"violates #{prm['exclusive-'+str] ? 'exclusive' : 'inclusive'} #{str} value #{prm[str].to_s}\"" }
% for p in params.select{ |q| q['type'].downcase == 'number'} # since we support arbitrary fields regardless of type
%  if p['minimum']
%   ncheck = "list.(#{idsym.(p)}).all? { |v| v.to_f %s #{p["minimum"]} }" % (p['exclusive-minimum'] ? '>' : '>=')
    params_errors.add(<%=idsym.(p) + ', ' + nerrmsg.(p,"minimum")%>) unless <%= nilcheck.(p) %> || <%= ncheck %>
%  end
%  if p['maximum']
%   ncheck = "list.(#{idsym.(p)}).all? { |v| v.to_f %s #{p["maximum"]} }" % (p['exclusive-maximum'] ? '<' : '<=')
    params_errors.add(<%=idsym.(p) + ', ' + nerrmsg.(p,"maximum")%>) unless <%= nilcheck.(p) %> || <%= ncheck %>
%  end
%  if p['integer']
%   ncheck = "( list.(#{idsym.(p)}).all? { |x| Integer(x.to_s) } rescue false )"
    params_errors.add(<%=idsym.(p)%>, "must be an integer") unless <%= nilcheck.(p) %> || <%= ncheck %>
%  end
% end

% end # min/max/int checks for numbers
%#
%# List properties check
% if params.any? { |p| p['list'] == true && (p['max-list-entries'] || p['min-list-entries']) }
% maxMap  = params.inject({}){ |hm,p| (mle = p['max-list-entries']) ? hm.merge(p['id'] => mle) : hm }
% minMap  = params.inject({}){ |hm,p| (mle = p['min-list-entries']) ? hm.merge(p['id'] => mle) : hm }
% lerrmsg = lambda { |m,val| "\"violates #{m} list length requirement (#{val})\"" }
% if maxMap.keys.length > 0
    # Check that max list lengths are not violated
%  params.select{ |p| p['list'] == true && p['max-list-entries'] }.each do |p|
%   lcheck = "( list.(#{idsym.(p)}).length <= #{maxMap[p['id']]} )"
    params_errors.add(<%= idsym.(p) + ', ' + lerrmsg.("max", maxMap[p['id']]) %>) unless <%= nilcheck.(p) %> || <%= lcheck %>
%  end

% end
% if minMap.keys.length > 0
    # Check that min list lengths are not violated
%  params.select{ |p| p['list'] == true && p['min-list-entries'] }.each do |p|
%   lcheck = "( list.(#{idsym.(p)}).length >= #{minMap[p['id']]} )"
    params_errors.add(<%= idsym.(p) + ', ' + lerrmsg.("min", minMap[p['id']]) %>) unless <%= nilcheck.(p) %> || <%= lcheck %>
%  end

% end
% end # min/max list length check
%#
%#
%####
%#  Write the checks for requires-inputs and disables-inputs.
%#  Indentation is to preserve pretty output
%#
%   # Helper for writing out a dictionary of keys to value arrays to a literal
%   writeLiteralMap = lambda do |name,inmap|
%     lenLongestKey = inmap.keys.map{ |x| x.to_s.length }.max + "''".length
    <%= "%s = {" % name %>
%     inmap.each do |key,valArr|
%       vals = valArr.map{ |s| ":'%s'" % s }.join(", ")
      <%= ":%-#{lenLongestKey}s => [%s]," % [ "'" + key + "'" , vals ] %>
%     end
    <%= "}" %>
%   end
%#
%   # Helper for writing out the checker loops
%   # Can write a loop checking either disables (base="disable") or requires (base="require") violations
%   generateCheckerLoop = lambda do |base|
%     key, vals, req = base + 'r', base + 'ds', base == "require"
    <%= base + "sMap.each do |"+key+", "+vals+"|" %>
      unless isInactive.(<%= key %>)
        for <%= base+'d' %> in <%= vals %>
          msg = <%='\'is %s \' + %s.pretty_params_names[%s]' % [base + 'd ' + (req ? 'for' : 'by'), name, key] %>
          params_errors.add(<%= base+'d' %>, msg) <%= req ? 'if' : 'unless' %> isInactive.(<%= base+'d' %>)
        end
      end
    end
%#
%   end
%#
%# Output to template
% unless requires_map.empty? and disables_map.empty?
%   comment = "# A Map: id -> [ids] where ids are the parameters %s by the input id"

    <%= (comment % "required") unless requires_map.empty? %>
%   writeLiteralMap.("requiresMap",requires_map) unless requires_map.empty?

    <%= (comment % "disabled") unless disables_map.empty? %>
%   writeLiteralMap.("disablesMap",disables_map) unless disables_map.empty?

% end
%#
% unless requires_map.empty?
    # Check that requires-inputs is not violated
    # If the parameter is filled in, the ones it requires must be too
%    generateCheckerLoop.("require")
% end

% unless disables_map.empty?
    # Check that disables-inputs is not violated
    # If the parameter is active, the ones it disables must not be
%    generateCheckerLoop.("disable")
% end
%#
%####
%# Check for violations pertaining to parameter groups
%# In particular, check that mutual exclusivity and one-is-required are satisfied
%#
% unless noGroups
%# Check if any groups require checking
% getGroupsWith = lambda { |prop| groups.select{ |g| g[prop] }.map{ |g| ":'"+g["id"]+"'" }.join(", ") }
% mutexGrps     = getGroupsWith.("mutually-exclusive")
% oneReqGrps    = getGroupsWith.("one-is-required")
% hasMutex      = (mutexGrps  != "")
% hasOneReq     = (oneReqGrps != "")
%#
% if (hasMutex || hasOneReq)

    # Groups with the mutually exclusive or one-is-required
    <%= 'mutexGroups = [%s]'  % mutexGrps  if hasMutex %>
    <%= 'oneReqGroups = [%s]' % oneReqGrps if hasOneReq %>
    # Mapping from groupId to members list
%   writeLiteralMap.("gidToMbrs", gIdToMbrs)
    # Mapping from groupId to group name
    grpName = {<%= groups.map{ |g| ":'" + g["id"] + "\' => \'" + g["name"] + "'" }.join(", ") %>}
% end
% if hasMutex
    # Lambda for checking mutual exclusivity
    isMutex = lambda { |gid| gidToMbrs[gid].select{ |m| ! isInactive.(m.to_sym) }.count <= 1 }
    mutexGroups.each do |group| # Check for violations of group mutex properties
      errMsg = "violates group mutual exclusivity requirement"
      params_errors.add(grpName[group], errMsg) unless isMutex.(group)
    end
% end
% if hasOneReq
    # Lambda for checking one-is-required (at least one is active)
    hasOneActive = lambda { |gid| gidToMbrs[gid].select{ |m| ! isInactive.(m.to_sym) }.count > 0 }
    oneReqGroups.each do |group| # Check for violations of group one-is-required properties
      errMsg = "violates group one-is-required specification"
      params_errors.add(grpName[group], errMsg) unless hasOneActive.(group)
    end
% end
%#
% end # noGroups check
%#
%# End parameter group properties check
%#
%#
    ### Perform validation checks on cbcsv files, if any are present ###
    # Get all the input cbcsv files
    cbcsvs = self.cbcsv_files
    # If a cbcsv file is present, generate a task for each entry
    # Note they should have been validate in after_form
    if (cbcsvs || []).length > 0
      numRows = nil
      # Validate each cbcsv (all columns match per row, user has access to the file)
      for id,cbcsv in cbcsvs
        # Error if the type is wrong
        # Current implementation will output an error here if a person uploads their cbcsv
        # but forgets to change its type to cbcsv. I.e. we assume it is an error to use
        # a .cbcsv for anything except generating a CbrainFileList object.
        # TODO may want to consider automatically converting such cases to CbrainFileLists
        unless cbcsv.is_a?(CbrainFileList)
          msg = " is not of type CbrainFileList! Please convert it with the file manager. (Type: #{cbcsv.class})"
          params_errors.add(id, msg) unless cbcsv.is_a?(CbrainFileList)
          next # This entry has enough problems
        end
        # Error if any of the files are not accessible or are non-existent
        begin
          fs = cbcsv.userfiles_accessibles_by!(self.user)
          for i in cbcsv.ordered_raw_ids.select{ |r| ! r.nil? }
            msg = " - unable to find file with id #{i}. Please check for correctness."
            params_errors.add(id, msg) if ( Userfile.find_accessible_by_user( i, self.user ) rescue nil ).nil?
          end
        rescue => e
          params_errors.add(id, " has inaccessible files! Ensure you own all the given files. (Received error: #{e.inspect})")
          next # No need to check other issues
        end
        # If the number of rows does not match, error
        currNumRows = (cbcsv.ordered_raw_ids || []).length
        numRows = numRows.nil? ? currNumRows : numRows
        params_errors.add(id, " does not match expected number of files (#{currNumRows} vs #{numRows})") unless currNumRows==numRows
        # Error if the rest of the cbcsv file has a problem
        # TODO this method does nothing right now
        allGood = cbcsv.validate_extra_attributes rescue false
        allGood ||= true
        params_errors.add(id, "has attributes that are invalid") unless allGood
      end
    end
%# End cbcsv validations

% end # End unless params.empty?
    ""
  end

  # Add pretty parameter names for the error messages to use
  # Associates the id symbol with the name field
  def self.pretty_params_names
    {
%     id_width = max_width.(params,"id") + "''".length
%     for param in params
      <%= ":%-#{id_width}s => '%s'," % ["'" + param["id"] + "'", param["name"]]  %>
%     end
    }
  end

  # Returns all the cbcsv files present, as tuples (id, Userfile)
  def cbcsv_files
    <%= "files = [%s]" % files.map { |f| ":'#{f['id']}'" }.join( ', ' ) %>
    return [] if files.nil? || files.length == 0
    files.select { |f| ! self.params[f].nil? }
         .map    { |f| [f, Userfile.find_accessible_by_user(self.params[f], self.user)] }
         .select { |f| f[1].name.end_with?('.cbcsv') || f[1].suggested_file_type == CbrainFileList }
  end

  # Final set of tasks to be launched based on this task's parameters. Only
  # useful if the parameters set for this task represent a set of tasks
  # instead of just one.
  def final_task_list #:nodoc:

    # TODO note: this assumes self.params[f] is a scalar i.e. not a File-type input with list : true
    # TODO modify the single file case below to handle any cbcsv files it gets appropriately? <- right now it would not be run

    # Grab all the cbcsv input files
    cbcsvs = self.cbcsv_files
    # If one or more cbcsv files is present, generate a task for each entry
    # Note they should have been validated in after_form
    if (cbcsvs || []).length > 0
      # Array with the actual userfiles corresponding to the cbcsv
      mapCbcsvToUserfiles = cbcsvs.map { |f| f[1].ordered_raw_ids }
      # Task list to fill and total number of tasks to output
      taskList, nTasks = [], mapCbcsvToUserfiles[0].length
      # Iterate over each task that needs to be generated
      for i in 0..(nTasks - 1)
        # Clone this task
        currTask = self.dup
        # Replace each cbcsv with an entry
        cbcsvs.map{ |f| f[0] }.each_with_index do |id,j|
          currId = mapCbcsvToUserfiles[j][i]
          currTask.params[:interface_userfile_ids] << mapCbcsvToUserfiles unless currId.nil?
          currTask.params[id] = currId
        end
        # Add the new task to our tasklist
        taskList << currTask
      end
      # Return the final set of tasks
      return taskList
    end

% if single_file
    # Create a list of tasks out of the default input file list
    # (interface_userfile_ids), each file going into parameter '<%= single_file['id'] %>'
    self.params[:interface_userfile_ids].map do |id|
      task = self.dup

      # Set and sanitize the one file parameter for each id
      task.params[:'<%= single_file['id']%>'] = id
%   if single_file['cbrain-file-type']
      task.sanitize_param(:'<%= single_file['id'] %>', :file, :file_type => '<%= single_file['cbrain-file-type']%>')
%   else
      task.sanitize_param(:'<%= single_file['id'] %>', :file)
%   end

      task.description ||= ''
      task.description  += " <%= single_file['id']%>: #{Userfile.find(id).name}"
      task.description.strip!
      task
    end
% else
    [ self ]
% end
  end

  # Task parameters to leave untouched by the edit task mechanism. Usually
  # for parameters added in after_form or final_task_list, as those wouldn't
  # be present on the form and thus lost when the task is edited.
  def untouchable_params_attributes #:nodoc:
% if outputs.empty?
    { }
% else
    # Output parameters will be present after the task has run and need to be
    # preserved.
    {
%   id_width = max_width.(outputs, 'id') + "'".length
%   outputs.each do |output|
      <%= ":'%-#{id_width}s => true," % (output['id'] + "'") %>
%   end
    }
% end
  end

  # Generic helper methods

  # Ensure that the parameter +name+ is not null and matches a generic tool
  # parameter +type+ (:file, :numeric, :string or :flag) before converting the
  # parameter's value to the corresponding Ruby type (if appropriate).
  # For example, sanitize_param(:deviation, :numeric) would validate that
  # self.params[:deviation] is a number and then convert it to a Ruby Float or
  # Integer.
  #
  # Available +options+:
  # [file_type] Userfile type to validate a parameter of +type+ :file against.
  #
  # If the parameter's value is an array, every value in the array is checked
  # and expected to match +type+.
  #
  # Raises an exception for task parameter +name+ if the parameter's value
  # is not adequate.
  def sanitize_param(name, type, options = {})
    # Taken userfile names. An error will be raised if two input files have the
    # same name.
    @taken_files ||= Set.new

    # Fetch the parameter and convert to an Enumerable if required
    values = self.params[name] rescue nil
    values = [values] unless values.is_a?(Enumerable)

    # Validate and convert each value
    values.map! do |value|
      case type
      # Try to convert to integer and then float. Cant? then its not a number.
      when :number
        if (number = Integer(value) rescue Float(value) rescue nil)
          value = number
        elsif value.blank?
          params_errors.add(name, ": value missing")
        else
          params_errors.add(name, ": not a number (#{value})")
        end

      # Nothing special required for strings, bar for symbols being acceptable strings.
      when :string
        value = value.to_s if value.is_a?(Symbol)
        params_errors.add(name, " not a string (#{value})") unless value.is_a?(String)

      # Try to match against various common representation of true and false
      when :flag
        if value.is_a?(String)
          value = true  if value =~ /^(true|t|yes|y|on|1)$/i
          value = false if value =~ /^(false|f|no|n|off|0|)$/i
        end

        if ! [ true, false ].include?(value)
          params_errors.add(name, ": not true or false (#{value})")
        end

      # Make sure the file ID is valid, accessible, not already used and
      # of the correct type.
      when :file
        unless (id = Integer(value) rescue nil)
          params_errors.add(name, ": invalid or missing userfile (ID #{value})")
          next value
        end

        unless (file = Userfile.find_accessible_by_user(value, self.user))
          params_errors.add(name, ": cannot find userfile (ID #{value})")
          next value
        end

        if @taken_files.include?(file.name)
          params_errors.add(name, ": file name already in use (#{file.name})")
        else
          @taken_files.add(file.name)
        end

        if type = options[:file_type]
          type = type.constantize unless type.is_a?(Class)
          params_errors.add(name, ": incorrect userfile type (#{file.name})") if
            type && ! file.is_a?(type)
        end
      end

      value
    end

    # Store the value back
    self.params[name] = values.first unless self.params[name].is_a?(Enumerable)
  end

end
