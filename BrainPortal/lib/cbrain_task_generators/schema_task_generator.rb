
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

require 'fileutils'

# This module handles generation of CbrainTasks from schema and descriptor
# files. The generated code can be added right away to CBRAIN's available tasks
# or written to file for later modification.
#
# NOTE: Only JSON and a single schema (boutiques) is currently supported
module SchemaTaskGenerator

  Revision_info=CbrainFileRevision[__FILE__] #:nodoc:

  # Directory where descriptor schemas are located
  SCHEMA_DIR = "#{Rails.root.to_s}/lib/cbrain_task_generators/schemas"

  # Default schema file to use when validating auto-loaded descriptors
  DEFAULT_SCHEMA_FILE = 'boutiques.schema.json'

  # Represents a schema to validate task descriptors against
  class Schema

    # Creates a new Schema from either a file path, a string or a hash
    # representing the schema.
    def initialize(schema)
      @schema = SchemaTaskGenerator.expand_json(schema)
    end

    # Validates +descriptor+ against the schema. Returns a list of validation
    # errors or nil if +descriptor+ is valid.
    def validate(descriptor)
      JSON::Validator.fully_validate(
        @schema,
        SchemaTaskGenerator.expand_json(descriptor),
        :errors_as_objects => true
      )
    end

    # Same as +validate+, but throws exceptions on validation errors instead.
    # Still returns nil if +descriptor+ is valid.
    def validate!(descriptor)
      JSON::Validator.validate!(
        @schema,
        SchemaTaskGenerator.expand_json(descriptor),
        :errors_as_objects => true
      )
    end

    # A Schema essentially behaves like a hash, as to allow accessing schema
    # properties. Forwards all other unknown method calls to Hash, if they
    # exist.
    def method_missing(method, *args) #:nodoc:
      if @schema.respond_to?(method)
        @schema.send(method, *args)
      else
        super
      end
    end

  end

  # Encapsulates a CbrainTask generated by this generator
  class GeneratedTask

    # Name of the generated class. Usually a camel-case form
    # of descriptor[:name].
    attr_accessor :name
    # Descriptor used to generate this task, in hash form.
    attr_accessor :descriptor
    # Schema instance used to generate this task.
    attr_accessor :schema
    # Validation errors produced when validating the task's descriptor, if any.
    attr_accessor :validation_errors
    # Generated Ruby/HTML source for this task. Hash with at least the keys:
    # [:portal]      BrainPortal side task class Ruby source. Contains a class
    #                inheriting/implementing PortalTask.
    # [:bourreau]    Bourreau side task class Ruby source. Contains a class
    #                inheriting/implementing ClusterTask.
    # [:task_params] Ruby ERB form template for the task's params (edit) page.
    # [:show_params] Ruby ERB template for the task's show page.
    # [:edit_help]   Ruby ERB template for the task's parameter help popup.
    attr_accessor :source

    # Create a new encapsulated generated CbrainTask from the output of the
    # generator (+SchemaTaskGenerator+::+generate+ method). +attributes+ is
    # expected to be a hash matching this object's attributes (:source, :name,
    # :descriptor, etc.)
    def initialize(attributes)
      attributes.each do |name, value|
        instance_variable_set("@#{name}", value)
      end
    end

    # Integrates the encapsulated CbrainTask in this CBRAIN installation.
    # Unless +register+ is specified to be false, this method will add the
    # required Tool and ToolConfig if necessary for the CbrainTask to be
    # useable right away (Since almost all information required to make the
    # Tool and ToolConfig objects is available in the spec).
    def integrate(register = true)
      # As the same code is used to dynamically load tasks descriptors and
      # create task templates, the class definitions are generated as strings
      # (Otherwise the source wouldn't be available to write down the generated
      # templates). This forces the use of eval instead of the much nicer,
      # faster and easier to maintain alternatives. :(
      eval @source[Rails.root.to_s =~ /BrainPortal$/ ? :portal : :bourreau]

      # Try and retrieve the just-generated task class
      task   = @name.camelize.constantize rescue nil
      task ||= "CbrainTask::#{@name.camelize}".constantize

      # Since the task class doesn't have a matching cbrain_plugins directory
      # tree, some methods need to be added/redefined to ensure the cooperation
      # of views and controllers.
      generated = self

      # The task class has no public_path.
      task.define_singleton_method(:public_path)    { |public_file| nil }

      # Make sure the task class still has access to its generated source
      task.define_singleton_method(:generated_from) { generated }

      # Offer access to the raw string version of the view partials for use
      # in views instead of the cbrain_plugins paths.
      task.define_singleton_method(:raw_partial) do |partial|
        ({
          :task_params => generated.source[:task_params],
          :show_params => generated.source[:show_params],
          :edit_help   => generated.source[:edit_help]
        })[partial];
      end

      return unless register

      # With the task class and descriptor, we have enough information to
      # generate a Tool and ToolConfig to register the tool into CBRAIN.
      # The newly created Tool and ToolConfig (if needed) will initially belong
      # to the core admin.

      name         = @descriptor['name']
      version      = @descriptor['tool-version'] || '(unknown)'
      description  = @descriptor['description']  || ''
      docker_image = @descriptor['docker-image']
      resource     = RemoteResource.current_resource

      # Create and save a new Tool for this task, unless theres already one.
      Tool.new(
        :name              => name,
        :user_id           => User.admin.id,
        :group_id          => User.admin.own_group.id,
        :category          => "scientific tool",
        :cbrain_task_class => task.to_s,
        :description       => description
      ).save! unless
        Tool.exists?(:cbrain_task_class => task.to_s)

      # Create and save a new ToolConfig for this task on this server, unless
      # theres already one. Only applies to Bourreaux (as it would make no
      # sense on the portal).
      return if Rails.root.to_s =~ /BrainPortal$/

      ToolConfig.new(
        :tool_id      => task.tool.id,
        :bourreau_id  => resource.id,
        :group_id     => Group.everyone.id,
        :version_name => version,
        :description  => "#{name} #{version} on #{resource.name}",
        :docker_image => docker_image
      ).save! unless
        ToolConfig.exists?(
          :tool_id      => task.tool.id,
          :bourreau_id  => RemoteResource.current_resource.id,
          :version_name => version
        )
    end

    # Writes the encapsulated CbrainTask as a directory tree under +path+ under
    # the CBRAIN plugin format;
    #   source[:portal]      -> <task name>/portal/<task name>.rb
    #   source[:bourreau]    -> <task name>/bourreau/<task name>.rb
    #   source[:task_params] -> <task name>/views/_task_params.html.erb
    #   source[:show_params] -> <task name>/views/_show_params.html.erb
    #   source[:edit_help]   -> <task name>/views/public/edit_params_help.html
    def to_directory(path)
      name = @name.underscore
      path = Pathname.new(path.to_s) + name

      FileUtils.mkpath(path)
      Dir.chdir(path) do
        ['portal', 'bourreau', 'views/public'].each { |d| FileUtils.mkpath(d) }

        IO.write("portal/#{name}.rb",                  @source[:portal])
        IO.write("bourreau/#{name}.rb",                @source[:bourreau])
        IO.write("views/_task_params.html.erb",        @source[:task_params])
        IO.write("views/_show_params.html.erb",        @source[:show_params])
        IO.write("views/public/edit_params_help.html", @source[:edit_help])
      end
    end

  end

  # Generates a CbrainTask from +descriptor+, which is expected to validate
  # against +schema+. +schema+ is expected to be either a +Schema+ instance,
  # a path to a schema file, the schema in string format or a hash
  # representing the schema.
  # Similarly to +schema+, +descriptor+ is expected to be either a path to a
  # descriptor file, the descriptor in string format or a hash representing
  # the descriptor.
  # By default, the validation of +descriptor+ against +schema+ is strict
  # and +generate+ will abort at any validation error. Set +strict_validation+
  # to false if you wish for the generator to try and generate the task despite
  # validation issues.
  def self.generate(schema, descriptor, strict_validation = true)
    descriptor = self.expand_json(descriptor)
    name       = descriptor['name'].camelize
    schema     = Schema.new(schema) unless schema.is_a?(Schema)
    errors     = schema.send(
      strict_validation ? :'validate!' : :validate,
      descriptor
    ) || []

    apply_template = lambda do |template|
      ERB.new(IO.read(
        Rails.root.join('lib/cbrain_task_generators/templates', template).to_s
      ), nil, '%<>>-').result(binding)
    end

    GeneratedTask.new(
      :name              => name,
      :descriptor        => descriptor,
      :schema            => schema,
      :validation_errors => errors,
      :source            => {
        :portal      => apply_template.('portal.rb.erb'),
        :bourreau    => apply_template.('bourreau.rb.erb'),
        :task_params => apply_template.('task_params.html.erb.erb'),
        :show_params => apply_template.('show_params.html.erb.erb'),
        :edit_help   => apply_template.('edit_help.html.erb')
      },
    )
  end

  # Returns the default Schema instance to use when validating descriptors
  # without a specific schema or when auto-loading descriptors.
  # (constructed from DEFAULT_SCHEMA_FILE)
  def self.default_schema
    @@default_schema ||= Schema.new("#{SCHEMA_DIR}/#{DEFAULT_SCHEMA_FILE}")
  end

  # Utility method to convert a JSON string or file path into a hash.
  # Returns the hash directly if a hash is given.
  def self.expand_json(obj)
    return obj unless obj.is_a?(String)

    JSON.parse!(File.exists?(obj) ? IO.read(obj) : obj)
  end

  private

  # Utility/helper methods used in templates.

  # Create a function call formatter for +func+ with possible arguments lists
  # +args+. The generated formatter will accept a list of arguments to format
  # a call with. (formatter.(['a', 'b']) -> 'func(a, b)')
  # If given, +block+ will be used to convert each value in +args+
  # (and the argument passed to the generated function) to an argument list.
  #
  # Example:
  #   a = [{ :a => 1, :b => 2 }, { :a => 2, :b => 4 }]
  #   f = format_call('f', a) { |a| [ a[:a], a[:b] ] }
  #   f.({ :a => 1, :b => 2}) # gives 'f(1, 2)'
  def self.format_call(func, args, &block)
    args = args.map { |a| block.(a) } if block

    widths = (args.first rescue []).zip(*args).map do |array|
      array.map { |v| v.length rescue 0 }.max + 1
    end

    lambda do |args|
      inner = (block ? block.(args) : args)
        .reject(&:blank?)
        .each_with_index
        .map { |v, i| "%-#{widths[i]}s" % (v + ',') }
        .join(' ')
        .gsub(/,\s*$/, '')

      "#{func}(#{inner})"
    end
  end

end
